orig.skw <- skewness(x, na.rm=T) # calculate skewness
if(abs(orig.skw)<=0.2){ # -0.2 < skewness < 0.2 is acceptable
transform.used <- 'None Needed'
new.skw <- orig.skw
}else if(orig.skw>0.2){ # first try Log Transformation on positive skew variables
transform.used <- 'Log Transformation'
new.skw <- skewness(log(x), na.rm=T)
}else if(orig.skw<(-0.2)){ # first try Square Transformation on negative skew variables
transform.used <- 'Square Transformation'
new.skw <- skewness((x^2), na.rm=T)
}
if(abs(new.skw)>0.2){ # still skewed? use Rank Transformation
transform.used <- 'Rank Transformation'
new.skw <- skewness(rank(x, na.last='keep'), na.rm=T)
}
if(abs(new.skw)>0.2){ # last resort is Bucket Transformation aka binning
transform.used <- 'Bucket Transformation'
new.skw <- NA
}
return(c(orig.skw, transform.used, new.skw))
}
myresults <- sapply(mydat[, myvars, with=F], myTransform.func)
skew <- sapply(mydat[, myvars, with=F], function(x) skewness(x, na.rm=T))
skew
sum(is.na(skew))
myresults <- lapply(mydat[, myvars, with=F], myTransform.func)
myresults
myTransform.func <- function(x){
orig.skw <- skewness(x, na.rm=T) # calculate skewness
if(abs(orig.skw)<=0.2){ # -0.2 < skewness < 0.2 is acceptable
transform.used <- 'None Needed'
new.skw <- orig.skw
}else if(orig.skw>0.2){ # first try Log Transformation on positive skew variables
transform.used <- 'Log Transformation'
new.skw <- skewness(log(x), na.rm=T)
}else if(orig.skw<(-0.2)){ # first try Square Transformation on negative skew variables
transform.used <- 'Square Transformation'
new.skw <- skewness((x^2), na.rm=T)
}
return(new.skw)
}
myresults <- lapply(mydat[, myvars, with=F], myTransform.func)
myresults
log(c(2, 3, 4, 5, NA))
log(c(2, 3, 4, 5, NA, -2))
logTrans <- function(y){
if(min(y, na.rm=T)>=1){
z <- log(y, na.rm=T)
}else{
ynew <- y+abs(min(y, na.rm=T))+1
z <- log(ynew, na.rm=T)
}
return(z)
}
logTrans(c(2, 3, 4, 5, NA, -2))
y <- c(2, 3, 4, 5, NA, -2)
y
min(y, na.rm=T)
min(y, na.rm=T)>=1
y+abs(min(y, na.rm=T))+1
myconstant <- abs(min(y, na.rm=T))+1
ynew <- y+myconstant
z <- log(ynew, na.rm=T)
?log
z <- log(y, na.rm=T)
z <- log(y)
z
z <- log(ynew, na.rm=T)
z <- log(ynew)
z
logTrans <- function(y){
if(min(y, na.rm=T)>=1){
z <- log(y)
}else{
myconstant <- abs(min(y, na.rm=T))+1
ynew <- y+myconstant
z <- log(ynew)
}
return(z)
}
logTrans(c(2, 3, 4, 5, NA, -2))
logTrans <- function(y){
if(min(y, na.rm=T)>=1){
z <- log(y)
}else{
myconstant <- abs(min(y, na.rm=T))+1
ynew <- y+myconstant
z <- log(ynew)
}
return(z)
}
library(moments)
myTransform.func <- function(x){
orig.skw <- skewness(x, na.rm=T) # calculate skewness
if(abs(orig.skw)<=0.2){ # -0.2 < skewness < 0.2 is acceptable
transform.used <- 'None Needed'
new.skw <- orig.skw
}else if(orig.skw>0.2){ # first try Log Transformation on positive skew variables
transform.used <- 'Log Transformation'
new.skw <- skewness(logTransform(x), na.rm=T)
}else if(orig.skw<(-0.2)){ # first try Square Transformation on negative skew variables
transform.used <- 'Square Transformation'
new.skw <- skewness((x^2), na.rm=T)
}
return(new.skw)
if(abs(new.skw)>0.2){ # still skewed? use Rank Transformation
transform.used <- 'Rank Transformation'
new.skw <- skewness(rank(x, na.last='keep'), na.rm=T)
}
if(abs(new.skw)>0.2){ # last resort is Bucket Transformation aka binning
transform.used <- 'Bucket Transformation'
new.skw <- NA
}
return(c(orig.skw, transform.used, new.skw))
}
myresults <- lapply(mydat[, myvars, with=F], myTransform.func)
logTrans <- function(y){
if(min(y, na.rm=T)>=1){
z <- log(y)
}else{
myconstant <- abs(min(y, na.rm=T))+1
ynew <- y+myconstant
z <- log(ynew)
}
return(z)
}
library(moments)
myTransform.func <- function(x){
orig.skw <- skewness(x, na.rm=T) # calculate skewness
if(abs(orig.skw)<=0.2){ # -0.2 < skewness < 0.2 is acceptable
transform.used <- 'None Needed'
new.skw <- orig.skw
}else if(orig.skw>0.2){ # first try Log Transformation on positive skew variables
transform.used <- 'Log Transformation'
new.skw <- skewness(logTrans(x), na.rm=T)
}else if(orig.skw<(-0.2)){ # first try Square Transformation on negative skew variables
transform.used <- 'Square Transformation'
new.skw <- skewness((x^2), na.rm=T)
}
return(new.skw)
if(abs(new.skw)>0.2){ # still skewed? use Rank Transformation
transform.used <- 'Rank Transformation'
new.skw <- skewness(rank(x, na.last='keep'), na.rm=T)
}
if(abs(new.skw)>0.2){ # last resort is Bucket Transformation aka binning
transform.used <- 'Bucket Transformation'
new.skw <- NA
}
return(c(orig.skw, transform.used, new.skw))
}
myresults <- lapply(mydat[, myvars, with=F], myTransform.func)
myresults
logTrans <- function(y){
if(min(y, na.rm=T)>=1){
z <- log(y)
}else{
myconstant <- abs(min(y, na.rm=T))+1
ynew <- y+myconstant
z <- log(ynew)
}
return(z)
}
library(moments)
myTransform.func <- function(x){
orig.skw <- skewness(x, na.rm=T) # calculate skewness
if(abs(orig.skw)<=0.2){ # -0.2 < skewness < 0.2 is acceptable
transform.used <- 'None Needed'
new.skw <- orig.skw
}else if(orig.skw>0.2){ # first try Log Transformation on positive skew variables
transform.used <- 'Log Transformation'
new.skw <- skewness(logTrans(x), na.rm=T)
}else if(orig.skw<(-0.2)){ # first try Square Transformation on negative skew variables
transform.used <- 'Square Transformation'
new.skw <- skewness((x^2), na.rm=T)
}
return(new.skw)
if(abs(new.skw)>0.2){ # still skewed? use Rank Transformation
transform.used <- 'Rank Transformation'
new.skw <- skewness(rank(x, na.last='keep'), na.rm=T)
}
if(abs(new.skw)>0.2){ # last resort is Bucket Transformation aka binning
transform.used <- 'Bucket Transformation'
new.skw <- NA
}
return(data.frame(orig.skw, transform.used, new.skw))
}
myresults <- sapply(mydat[, myvars, with=F], myTransform.func)
myresults
logTrans <- function(y){
if(min(y, na.rm=T)>=1){
z <- log(y)
}else{
myconstant <- abs(min(y, na.rm=T))+1
ynew <- y+myconstant
z <- log(ynew)
}
return(z)
}
library(moments)
myTransform.func <- function(x){
orig.skw <- skewness(x, na.rm=T) # calculate skewness
if(abs(orig.skw)<=0.2){ # -0.2 < skewness < 0.2 is acceptable
transform.used <- 'None Needed'
new.skw <- orig.skw
}else if(orig.skw>0.2){ # first try Log Transformation on positive skew variables
transform.used <- 'Log Transformation'
new.skw <- skewness(logTrans(x), na.rm=T)
}else if(orig.skw<(-0.2)){ # first try Square Transformation on negative skew variables
transform.used <- 'Square Transformation'
new.skw <- skewness((x^2), na.rm=T)
}
if(abs(new.skw)>0.2){ # still skewed? use Rank Transformation
transform.used <- 'Rank Transformation'
new.skw <- skewness(rank(x, na.last='keep'), na.rm=T)
}
if(abs(new.skw)>0.2){ # last resort is Bucket Transformation aka binning
transform.used <- 'Bucket Transformation'
new.skw <- NA
}
return(data.frame(orig.skw, transform.used, new.skw))
}
myresults <- sapply(mydat[, myvars, with=F], myTransform.func)
myresults
class(myresults)
data.table(myresults)
data.table(t(myresults))
dimnames(myresults)
row.names(myresults.final)
myresults.final <- data.table(t(myresults))
row.names(myresults.final)
myresults.final$Variable <- colnames(myresults)
myresults.final
names(myresults.final)
setnames(myresults.final, c('Original Skewness', 'Transformation Used', 'New Skewness', 'Variable'))
?write.csv
write.csv(myresults.final[, c('Variable', 'Original Skewness', 'Transformation Used', 'New Skewness'), with=F], 'C:/Users/Robert/cloud/Classes/Data Prep/Assignment 4/Data Transformation Summary.csv', row.names=F, na='N/A')
write.csv(x=myresults.final[, c('Variable', 'Original Skewness', 'Transformation Used', 'New Skewness'), with=F], file='C:/Users/Robert/cloud/Classes/Data Prep/Assignment 4/Data Transformation Summary.csv', row.names=F, na='N/A')
?fwrite
lapply(mydat.final, class)
lapply(myresults.final, class)
myresults.final[, 'New Skewness', with=F]
logTrans <- function(y){
if(min(y, na.rm=T)>=1){
z <- log(y)
}else{
myconstant <- abs(min(y, na.rm=T))+1
ynew <- y+myconstant
z <- log(ynew)
}
return(z)
}
library(moments)
myTransform.func <- function(x){
orig.skw <- skewness(x, na.rm=T) # calculate skewness
if(abs(orig.skw)<=0.2){ # -0.2 < skewness < 0.2 is acceptable
transform.used <- 'None Needed'
new.skw <- orig.skw
}else if(orig.skw>0.2){ # first try Log Transformation on positive skew variables
transform.used <- 'Log Transformation'
new.skw <- skewness(logTrans(x), na.rm=T)
}else if(orig.skw<(-0.2)){ # first try Square Transformation on negative skew variables
transform.used <- 'Square Transformation'
new.skw <- skewness((x^2), na.rm=T)
}
if(abs(new.skw)>0.2){ # still skewed? use Rank Transformation
transform.used <- 'Rank Transformation'
new.skw <- skewness(rank(x, na.last='keep'), na.rm=T)
}
if(abs(new.skw)>0.2){ # last resort is Bucket Transformation aka binning
transform.used <- 'Bucket Transformation'
new.skw <- NA
}
return(data.frame(orig.skw, transform.used, new.skw))
}
myresults <- sapply(mydat[, myvars, with=F], myTransform.func)
myresults.final <- t(myresults)
myresults.final$Variable <- colnames(myresults)
setnames(myresults.final, c('Original Skewness', 'Transformation Used', 'New Skewness', 'Variable'))
# export to .csv
write.csv(x=myresults.final[, c('Variable', 'Original Skewness', 'Transformation Used', 'New Skewness'), with=F], file='C:/Users/Robert/cloud/Classes/Data Prep/Assignment 4/Data Transformation Summary.csv', row.names=F, na='N/A')
View(myresults)
myTransform.func <- function(x){
orig.skw <- skewness(x, na.rm=T) # calculate skewness
if(abs(orig.skw)<=0.2){ # -0.2 < skewness < 0.2 is acceptable
transform.used <- 'None Needed'
new.skw <- orig.skw
}else if(orig.skw>0.2){ # first try Log Transformation on positive skew variables
transform.used <- 'Log Transformation'
new.skw <- skewness(logTrans(x), na.rm=T)
}else if(orig.skw<(-0.2)){ # first try Square Transformation on negative skew variables
transform.used <- 'Square Transformation'
new.skw <- skewness((x^2), na.rm=T)
}
if(abs(new.skw)>0.2){ # still skewed? use Rank Transformation
transform.used <- 'Rank Transformation'
new.skw <- skewness(rank(x, na.last='keep'), na.rm=T)
}
if(abs(new.skw)>0.2){ # last resort is Bucket Transformation aka binning
transform.used <- 'Bucket Transformation'
new.skw <- NA
}
return(c(orig.skw, transform.used, new.skw))
}
myresults <- sapply(mydat[, myvars, with=F], myTransform.func)
class(myresults)
View(myresults)
c(3, 'x', 5)
t(c(3, 'x', 5))
myTransform.func <- function(x){
orig.skw <- skewness(x, na.rm=T) # calculate skewness
if(abs(orig.skw)<=0.2){ # -0.2 < skewness < 0.2 is acceptable
transform.used <- 'None Needed'
new.skw <- orig.skw
}else if(orig.skw>0.2){ # first try Log Transformation on positive skew variables
transform.used <- 'Log Transformation'
new.skw <- skewness(logTrans(x), na.rm=T)
}else if(orig.skw<(-0.2)){ # first try Square Transformation on negative skew variables
transform.used <- 'Square Transformation'
new.skw <- skewness((x^2), na.rm=T)
}
if(abs(new.skw)>0.2){ # still skewed? use Rank Transformation
transform.used <- 'Rank Transformation'
new.skw <- skewness(rank(x, na.last='keep'), na.rm=T)
}
if(abs(new.skw)>0.2){ # last resort is Bucket Transformation aka binning
transform.used <- 'Bucket Transformation'
new.skw <- NA
}
return(t(c(orig.skw, transform.used, new.skw)))
}
myresults <- sapply(mydat[, myvars, with=F], myTransform.func)
View(myresults)
myTransform.func <- function(x){
orig.skw <- skewness(x, na.rm=T) # calculate skewness
if(abs(orig.skw)<=0.2){ # -0.2 < skewness < 0.2 is acceptable
transform.used <- 'None Needed'
new.skw <- orig.skw
}else if(orig.skw>0.2){ # first try Log Transformation on positive skew variables
transform.used <- 'Log Transformation'
new.skw <- skewness(logTrans(x), na.rm=T)
}else if(orig.skw<(-0.2)){ # first try Square Transformation on negative skew variables
transform.used <- 'Square Transformation'
new.skw <- skewness((x^2), na.rm=T)
}
if(abs(new.skw)>0.2){ # still skewed? use Rank Transformation
transform.used <- 'Rank Transformation'
new.skw <- skewness(rank(x, na.last='keep'), na.rm=T)
}
if(abs(new.skw)>0.2){ # last resort is Bucket Transformation aka binning
transform.used <- 'Bucket Transformation'
new.skw <- NA
}
return(c(orig.skw, transform.used, new.skw))
}
myresults <- lapply(mydat[, myvars, with=F], myTransform.func)
myresults.df <- rbindlist(myresults)
myTransform.func <- function(x){
orig.skw <- skewness(x, na.rm=T) # calculate skewness
if(abs(orig.skw)<=0.2){ # -0.2 < skewness < 0.2 is acceptable
transform.used <- 'None Needed'
new.skw <- orig.skw
}else if(orig.skw>0.2){ # first try Log Transformation on positive skew variables
transform.used <- 'Log Transformation'
new.skw <- skewness(logTrans(x), na.rm=T)
}else if(orig.skw<(-0.2)){ # first try Square Transformation on negative skew variables
transform.used <- 'Square Transformation'
new.skw <- skewness((x^2), na.rm=T)
}
if(abs(new.skw)>0.2){ # still skewed? use Rank Transformation
transform.used <- 'Rank Transformation'
new.skw <- skewness(rank(x, na.last='keep'), na.rm=T)
}
if(abs(new.skw)>0.2){ # last resort is Bucket Transformation aka binning
transform.used <- 'Bucket Transformation'
new.skw <- NA
}
return(data.frame(orig.skw, transform.used, new.skw))
}
myresults <- lapply(mydat[, myvars, with=F], myTransform.func)
myresults.df <- rbindlist(myresults)
View(myresults.df)
View(myresults.df)
colnames(myresults)
names(myresults)
myresults.df$Variable <- names(myresults)
setnames(myresults.final, c('Original Skewness', 'Transformation Used', 'New Skewness', 'Variable'))
setnames(myresults.df, c('Original Skewness', 'Transformation Used', 'New Skewness', 'Variable'))
write.csv(x=myresults.df[, c('Variable', 'Original Skewness', 'Transformation Used', 'New Skewness'), with=F], file='C:/Users/Robert/cloud/Classes/Data Prep/Assignment 4/Data Transformation Summary.csv', row.names=F, na='N/A')
View(myresults.df)
install.packages('ipop')
install.packages('kernlab')
library(kernlab)
namespace(kernlab)
namespace::kernlab
loadNamespace(kernlab)
loadNamespace('kernlab')
environment: namespace:kernlab
<environment: namespace:kernlab>
?ipop
114/3
death <- matrix(c(135, 310, 205, 55, 155, 140), nrow=2, byrow=T)
rownames(death) <- c('Smoker', 'Nonsmoker')
colnames(death) <- c('Cancer', 'Heart Disease', 'Other')
chisq.test(death, correct=F)$expected == chisq.test(death, correct=T)$expected
crab <- read.table('C:/Users/Robert/cloud/Classes/Categorical Data Analysis/crab.txt', header=T)
View(crab)
summary(crabs)
summary(crab)
crab$color <- mapvalues(crab$color, from=c(1, 2, 3, 4, 5), to=c('light', 'medium light', 'medium', 'medium dark', 'dark'))
library(plyr)
crab$color <- mapvalues(crab$color, from=c(1, 2, 3, 4, 5), to=c('light', 'medium light', 'medium', 'medium dark', 'dark'))
summary(crab$color)
crab$color <- factor(mapvalues(crab$color, from=c(1, 2, 3, 4, 5), to=c('light', 'medium light', 'medium', 'medium dark', 'dark')))
crab <- read.table('C:/Users/Robert/cloud/Classes/Categorical Data Analysis/crab.txt', header=T)
library(plyr)
crab$color <- factor(mapvalues(crab$color, from=c(1, 2, 3, 4, 5), to=c('light', 'medium light', 'medium', 'medium dark', 'dark')))
summary(crab$color)
names(crab)
mod1 <- glm(weight~width+color, family=binomial)
mod1 <- glm(weight~width+color, family=binomial, data=crab)
lapply(crab, table)
with(crab, weight=weight/1000)
with(crab, color=color-1)
crab <- read.table('C:/Users/Robert/cloud/Classes/Categorical Data Analysis/crab.txt', header=T)
with(crab, weight=weight/1000)
crab <- read.table('C:/Users/Robert/cloud/Classes/Categorical Data Analysis/crab.txt', header=T)
crab$weight <- crab$weight/1000
crab$color <- crab$color-1
crab$satell <- ifelse(crab$satell>0, 1, 0)
library(plyr)
crab$color <- factor(mapvalues(crab$color, from=c(1, 2, 3, 4), to=c('medium light', 'medium', 'medium dark', 'dark')))
rm(death)
mod1 <- glm(satell~width+color, family=binomial, data=crab)
newdata <- expand.grid(width=c(18:34), color=unique(crab$color))
View(newdata)
mypred <- predict(newdata, mod1)
?predict
mypred <- predict(mod1, newdata=newdata)
names(mypred)
dim(mypred)
newdata$predicted <- predict(mod1, newdata=newdata)
ggplot(mypred, aes(x=width, y=predicted, color=color))+
geom_line()
library(ggplot2)
ggplot(mypred, aes(x=width, y=predicted, color=color))+
geom_line()
newdata <- expand.grid(width=c(18:34), color=unique(crab$color))
newdata$predicted <- predict(mod1, newdata=newdata)
library(ggplot2)
ggplot(newdata, aes(x=width, y=predicted, color=color))+
geom_line()
newdata <- expand.grid(width=c(18:34), color=unique(crab$color))
newdata$predicted <- predict(mod1, type='response', newdata=newdata)
library(ggplot2)
ggplot(newdata, aes(x=width, y=predicted, color=color))+
geom_line()
theme_set(theme_bw(base_size=16))
theme_update(axis.text.x=element_text(angle=35, vjust=1, hjust=1))
theme_update(panel.grid.major=element_line(colour="#CCCCCC", size=0.3), panel.grid.minor=element_line(colour="grey96", size=0.7))
white <- c(17, 15, 5, 1, 2, 3, 4, 2, 1, 1, 1, 0, 8, 10, 10, 2, 8, 5, 4, 1, 7, 3, 2, 2)
black <- c(37, 102, 160, 59, 17, 9, 85, 52, 25, 45, 15, 16, 34, 103, 141, 64, 54, 19, 71, 74, 129, 30, 23, 31)
mean(c(black, white))
striped <- c(13, 3, 2, 3, 1, 0, 0, 0, 0, 0, 0, 3, 0, 1, 4, 3, 1, 0, 1, 0, 3, 10, 0, 1)
mean(striped)
mean(white)
length(striped)
striped <- c(striped, 12, 0, 0, 6, 3, 3, 2, 0, 0, 1, 1, 1, 2, 0, 0, 0, 0, 0)
mean(striped)
length(striped)
sd(striped)
library(data.table)
setwd('C:/Users/Robert/cloud/Classes/Data Prep/Final Project')
train <- fread('SASData/WANGphy_train.csv', na.strings=c('999', '9999'))
# create missing value indicators
sapply(names(train), function(x){
dat <- with(train, get(x))
if(sum(is.na(dat))>0){
newname <- paste0('I', x)
train[, as.character(newname):=is.na(dat)]
}
})
sapply(train, function(x) sum(is.na(x)))
?fread
?grep
myCols <- grep('I', names(train), value=T)
myCols
tmp <- mydat[, myCols, with=F]
tmp <- train[, myCols, with=F]
fit <- princomp(tmp, cor=T) # PCA fit
biplot(fit) # biplot
summary(fit)
myCols
fit
?princomp
library(nFactors)
install.packages('nFactors')
install.packages("nFactors")
getwd()
library(data.table)
train <- fread('SASData/WANGphy_train.csv', na.strings=c('999', '9999'))
# create missing value indicators
sapply(names(train), function(x){
dat <- with(train, get(x))
if(sum(is.na(dat))>0){
newname <- paste0('I', x)
train[, as.character(newname):=is.na(dat)]
}
})
names(train)
View(train)
train <- fread('SASData/WANGphy_train.csv')
sapply(train, function(x) sum(is.na(x)))
